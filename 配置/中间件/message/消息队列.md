


消息队列的主要作用：

1. 削峰填谷 ：消息队列的主要作用，主要用在秒杀场景。但是，会造成请求处理的延迟。
2. 异步处理 ：提升响应速度。
3. 解耦合：提升系统的鲁棒性。

什么事鲁棒性



秒杀场景，使用消息队列的话，怎么保证秒杀产品不超卖？

主要有两种方法：

● 使用锁的方式，比如分布式锁，也可以利用 redis 本身操作原子性的特点
● 写入消息队列，在消息队列中做减库存的操作，做异步校验



如何保证消息仅仅被消费一次？

如何保证消息不被重复消费？

如何提升消费性能保证更短的消息延迟呢？



### 消息队列有什么优缺点

### 怎样保证消息队列的高可用性


A 系统通过 RabbitMQ 调用 B 系统，A 发消息就立刻返回了
为防止消息被多次投递（网络抖动、重试），B 系统的业务逻辑必须是幂等的，比如根据消息唯一 ID 判断是否已经处理过。


## 那 A 系统如何感知 “调用是否成功”？

MQ 是异步模式，A 系统通常不直接感知 B 系统的处理结果。但有几种常见的实现：
可靠消息 + 补偿机制（常用）
A 系统先把消息存一份到本地数据库（发送日志）。
RabbitMQ confirm ack 后，把状态更新为“已投递”。
B 系统处理完后，回调 / 发确认消息给 A 系统，A 更新为“已完成”。
如果 B 系统没处理，A 可以通过定时任务扫描“未完成”的消息，进行补偿。
消息回执（业务层 Ack）
B 系统在消费完成后，主动发一个“处理成功”事件（或调用 A 系统接口）。
A 系统根据这个回执判断调用是否最终成功。
分布式事务（最终一致性思路）
借助事务消息（比如 RocketMQ 的事务消息）或者 Outbox 模式，保证消息发送和本地事务同时成功。
这样即便 B 系统失败，也能通过补偿让系统达到最终一致。


A 系统发消息后立刻返回是 异步解耦的特点。
保证调用成功需要两方面：
消息可靠送达 MQ → 依靠 confirm + 持久化。
消息可靠消费 → 依靠消费者 ack + 死信队列 + 幂等性。
A 系统如果要感知 B 系统是否处理成功，通常用 回执机制 / 消息表补偿 / 分布式事务 来保证最终一致性。



## 需要控制系统B处理消息的速度