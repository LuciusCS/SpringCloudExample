

## ️ 分库额分表 典型限制
   
           限制	                             原因	                                影响
         跨库事务	    每个分库在不同实例/集群，本地事务无法保证 ACID	     如果强制使用本地事务，可能导致数据不一致
        跨库 JOIN	                 不同分库物理表在不同实例	                SQL 不支持，或者性能极差
  COUNT / SUM / AVG 等聚合	         跨分片聚合需要应用层合并	                    大表聚合性能低
    ORDER BY / GROUP BY	          跨分片排序/分组需要应用层合并	                 数据量大时性能受影响

##  高 OPS 场景解决方案

### 方案一：业务拆分 + 分片键优化（推荐高 OPS）
   - 核心思想：
      * 设计分片键，使关联查询尽量在 同一个分片
      * 避免跨分片事务和 JOIN
   - 优点：性能最好，适合高并发
   - 缺点：业务设计复杂，需要根据查询热点优化分片键
   - 示例：
      * 用户表 user 和订单表 order 按 user_id % N 分库分表
      * 同一用户的数据落在同一分片 → 同库事务可用，JOIN 高效

###  方案二：局部事务 + 应用层最终一致性
   - 核心思想：
      * 分库分表内保持本地事务
      * 跨分片操作依赖 应用逻辑处理 或 补偿机制
   - 适合场景：大多数业务操作，追求高 OPS 而非严格跨分片事务强一致性
   - 方式：
      * 业务操作拆分为多步
      * 异步补偿失败操作（例如延迟队列 / 消息队列）

###  方案三：分布式事务（XA/TCC/Seata 等）
   - 核心思想：通过分布式事务框架保证跨库事务 ACID
   - 适合场景：低并发、高一致性场景（如金融核心业务）
   - 缺点：性能开销大，高 OPS 场景可能成为瓶颈
   - 注意：
      * XA → MySQL 内置支持，但 TPS 低
      * TCC / AT（Seata） → 性能比 XA 好，但增加开发复杂度

###  方案四：跨库聚合优化
   - 核心思想：避免大表跨库聚合
   - 做法：
      * 预计算 / 中间表 / 物化视图
      * 使用缓存（Redis / Elasticsearch）存储聚合结果
      * 对 ORDER BY / GROUP BY 仅在分片内排序 → 应用层合并
   - 适合场景：高 OPS 查询场景，减少跨库聚合压力

## 总结建议（高 OPS 场景）
   - 尽量在同一个分片内完成事务 → 保留本地事务
   - 分布式事务只在必要时使用 → XA/TCC/Seata，避免高并发瓶颈
   - 跨库聚合/排序 → 尽量预计算或缓存，减少实时跨库操作
   - 分片键设计 → 决定性能瓶颈，必须按业务查询热点优化
   - 高 OPS 核心原则 → 避免跨分片操作、减少分布式事务
⚠️ 核心思路：能在单分片完成的事务就不分片，跨分片的操作尽量异步或用补偿机制。