




## XtraBackup 备份与恢复脚本（支持 MySQL 8.0 + 全量 + 增量 + 恢复到任意天


✅ backup_full.sh：每周一次全量备份
✅ backup_incr.sh：每日增量备份（基于最近全量或增量）
✅ restore_to.sh：恢复到指定日期的备份数据目录（需手动替换当前 MySQL 数据目录）
✅ binlog_replay.sh（回放 binlog，恢复到指定时间点）
✅ extract_table_from_restore.sh（从临时恢复实例导出表）误删数据恢复 - 从临时实例导出数据
✅ run_temp_instance.sh（启动临时 MySQL 实例）

## 恢复到某天执行语句

```

bash restore_to.sh 2025-06-04

```


## 定时任务（cron）部署：

```

# 每周日凌晨 2 点跑全量
0 2 * * 0 /path/to/backup_full.sh

# 每周一到六凌晨 2 点跑增量
0 2 * * 1-6 /path/to/backup_incr.sh
```


## 备份文件压缩上传（可加密+上传 OSS/S3）
## 定期校验恢复（自动测试恢复+数据一致性比对）

## 恢复步骤

步骤 1：恢复全量和增量备份（恢复到 6 月 26 日）
```
bash restore_to.sh 2025-06-26

```
该步骤将恢复你最近的全量备份和增量备份，并还原到 2025 年 6 月 26 日的状态。

步骤 2：回放 binlog 恢复到时间点（6 月 27 日 11:30）
假设 binlog 存储在 /var/lib/mysql，我们可以回放到 6 月 27 日 11:30：
```
bash binlog_replay.sh "2025-06-27 00:00:00" "2025-06-27 11:30:00"
```
该步骤会根据 binlog 文件回放写入的 SQL，恢复所有 6 月 27 日 11:30 前的数据。




步骤 3：误删数据恢复（从临时实例导出误删表）
假设你误删了 orders 表，可以通过临时实例导出该表的 6 月 26 日数据：
先启动临时实例（参考前面 run_temp_instance.sh 脚本）：
```
bash run_temp_instance.sh
```
导出误删的 orders 表：
```
bash extract_table_from_restore.sh orders yourdb
```
这会将 6 月 26 日的 orders 表导出到 /tmp/orders_dump.sql。
步骤 4：将误删数据导入到主库
最后，将误删的 orders 表数据导入到主库：
```
mysql -u root -p yourdb < /tmp/orders_dump.sql

```
这样，你就恢复了误删的 orders 表，而不影响其他表的数据。
✅ 完整流程总结
恢复全量+增量备份到目标日期（如 6 月 26 日）。
回放 binlog 恢复到指定时间点（如 6 月 27 日 11:30）。
从临时恢复实例导出误删表（如 orders 表）。
导入误删数据到当前主库。



## 使用临时脚本，恢复误删的表

如何使用 run_temp_instance.sh 脚本
确保备份目录已经准备好：该脚本依赖于从 xtrabackup 恢复的目录。你需要提前执行 restore_to.sh 来恢复到目标日期的备份（例如 6 月 26 日）。
执行脚本启动临时实例：
你可以使用以下命令来启动临时实例：

```
bash run_temp_instance.sh
```

该脚本会启动一个临时的 MySQL 实例，端口为 3307，socket 文件为 /tmp/mysql_restore.sock。
使用临时实例：
你可以通过 mysqldump 或者其他方法从该临时实例中导出误删的数据。
比如，导出 orders 表：
```
mysqldump -S /tmp/mysql_restore.sock -P 3307 -u root yourdb orders > /tmp/orders_2025-06-26.sql
```
停止临时实例：
在完成数据导出后，你可以手动停止临时实例，或者通过以下命令停止：

kill $(cat /tmp/mysql_restore.pid)






## 注意

做物理备份（XtraBackup）时，不建议走 MySQL Router 或 VIP