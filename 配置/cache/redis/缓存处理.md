

## 示例代码

 order-server 模块中

` com.example.order.service.impl.StationServiceImpl.java`

在使用 Redis 对请求数据进行缓存时，缓存注解（如 @Cacheable）应该放在 Service 层，
而不是 Controller 层。这是 Spring 推荐的最佳实践，也是实际项目中更合理的架构方式。


## 职责划分清晰（Separation of Concerns）
Controller 层的职责是 处理 HTTP 请求/响应、参数校验、权限判断等。
Service 层负责 业务逻辑处理，包括缓存、数据库操作、计算等。
➡️ 缓存属于业务层的横切关注点，应当由 Service 层处理。


##  AOP 机制限制：Controller 缓存可能无效
Spring 的缓存注解（如 @Cacheable, @CacheEvict, @CachePut）是通过 Spring AOP 实现的。
❗ AOP 机制只能作用在 被 Spring 容器管理的 Bean 且通过代理方式调用的方法 上。
如果你把 @Cacheable 放在 Controller 中，且自己内部调用方法，可能不会触发缓存逻辑。

### 对比
项目	        放在 Controller   	放在 Service ✅
职责清晰性	    ❌ 逻辑混乱	    ✅ 分层清晰
可复用性	        ❌ 难以复用	    ✅ 高复用
缓存粒度	      ❌ 缓存包装数据	    ✅ 缓存业务数据
AOP 支持	      ❌ 可能无效	    ✅ 支持完全

## 缓存清理，区别

```
@CacheEvict(value = "stationCacheList", key = "'stations:' + '*'")  
    @CacheEvict(value = "stationCacheList", allEntries = true)  
```
### 1. @CacheEvict(value = "stationCacheList", key = "'stations:' + '*'")
   含义：尝试清除 stationCacheList 缓存中 key 是 'stations:*' 这种字面字符串的缓存项。
   作用：只能清除key完全等于 'stations:*' 的缓存项，而不会匹配以 'stations:' 开头的所有缓存项。
   说明：
       这里的 key 是固定字符串表达式，'*' 并不是通配符。
       Spring Cache 不支持模糊匹配或通配符清理。
       实际很少用，因为通常 key 会带分页参数、过滤参数，写成 'stations:' + '*' 是无效的模糊匹配。
### 2. @CacheEvict(value = "stationCacheList", allEntries = true)
  含义：清除 stationCacheList 缓存中的所有缓存项。
  作用：无论 key 是什么，stationCacheList 下面所有缓存都会被清除。
  说明：
       这是官方推荐的清理缓存列表的方式，尤其分页等动态key情况，无法预先知道全部key时。
       简单直接，确保分页列表缓存数据完全失效，避免脏数据。
  
#### 对比
特性          	@CacheEvict(key = "'stations:' + '*'")	        @CacheEvict(allEntries = true)
作用范围                	尝试匹配特定模式的键	                        整个缓存区域的所有键
实际效果	            通常无效（除非底层缓存支持通配符删除）	        立即生效，清除所有缓存
实现机制        	生成字面键 "stations:*" 进行精确匹配	        调用 Cache.clear() 方法清除整个缓存区域
性能影响	                可能遍历所有键（如果支持通配符）	                直接清除整个缓存区域，效率更高
适用场景        	不推荐使用（Spring Cache 原生不支持通配符删除）	    需要批量清理整个缓存时使用

## 缓存需要进行回滚吗？
Spring Cache 操作默认不参与事务回滚
Spring 的缓存注解（@CachePut、@CacheEvict 等）默认在 方法执行成功后才触发，但它们本身不是事务性操作。因此：
如果方法执行到数据库更新失败抛异常，缓存不会被更新（这是预期行为，✔️）。
如果缓存操作抛异常，默认 不会回滚数据库事务 ❌ —— 需要你手动处理。


```java
@CachePut(value =  "stationCacheById", key = "'station:' + #station.id")
@CacheEvict(value = "stationCacheList", allEntries = true)
@Transactional
public StationDTO update(StationDTO station) {
    // 数据库更新逻辑
    return station;
}
```
#### 它的执行逻辑是：
1、Spring 在执行 update() 前记录事务；
2、方法执行完成，进入事务提交阶段；
3、事务成功后，@CachePut、@CacheEvict 才生效。
4、 如果数据库更新失败并抛异常，整个事务回滚，缓存不会更新或清除 → ✅ 是你希望的行为。


### Redis 的使用方法
1、使用RedisTemplate
2、使用 Spring Cache 


### 一个Redis 一共有几个库
在 Redis 中，默认情况下提供 16 个数据库，编号从 0 到 15，即 Redis 实例默认拥有 16 个数据库。
Redis 理论上 支持修改 redis.conf 配置文件中参数，来增加数据库数量，但是并不推荐在生产环境中使用超过默认的 16 个数据库，
因为 Redis 的设计并不是为了支持大量的数据库。Redis 的数据库数量本质上并不代表多个隔离的数据库，
而只是通过数字索引来区分不同的数据库，它们之间的隔离程度较低，实际上 Redis 仍然是一个全局的键空间。

### 在微服务中应该对这些库进行怎样的使用
每个微服务都有自己的 Redis 实例或在同一 Redis 实例中使用不同的数据库。这样做可以避免不同微服务的数据混淆，并且可以根据不同服务的需求进行调优。

### 单个Redis 能提供 2-3 万 qps


### Redis 的key在微服务中应该怎样进行命名

```
<service>:<module>:<entity>:<operation>:<identifier>
```
解释：
<service>：服务名称或微服务的标识，用于区分不同的微服务。
<module>：功能模块或业务线的标识，用于进一步划分不同的功能领域。
<entity>：实体对象的类型，表示缓存的实际数据对象类型，如 user、order 等。
<operation>：操作类型，表示缓存的操作内容，如 get、set、delete、list 等。
<identifier>：唯一标识符，通常是数据的主键、ID 或其他可唯一标识某个资源的字段。