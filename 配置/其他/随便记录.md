




提升Spring Boot单体jar包的并发数，其实没有意义，因为真实项目里基本用不到。
1 如果是一般项目，并发量的要求也就几十个，启动个spring boot，其实是运行在tomcat里，怎么地都能满足这个并发量。
2 如果项目真有并发需求，比如是几千甚至几万，大概率是通过搭建jar包集群，或者采用其它措施来提升并发量，而不会单纯提升单体版的并发量。
3 顺着上述两点再扩展一下，当下提升并发量，或者其它涉及到高并发的需求，一般都是通过分布式和微服务组件来实现，
当然也可以通过提升tomcat（或mysql）的一些配置，但在代码层面，只要别写过于离谱的代码就行，比如就别写过深的循环，
即没指望过单纯写代码来提升性能。比如在面试场景，我问高并发这块，如果有人告诉我，是通过改进tomcat等配置，
我会认为至少实践过，如果有人告诉我是用搭建集群的方法，那一般是有经验的，如果再能说出些在搭建集群和使用组件时，
解决过实际问题，那应该是经验丰富。但如果单纯告诉我，是通过写代码来提升，比如是在代码里用多线程或并发锁这套，
这就属于基本没经验，是单纯靠背面试题来说。那么在实际项目里，一般会如何提升并发量呢？
1 最简单粗暴的是加节点。比如一个spring boot项目打成jar包放到服务器运行后，发现性能不行，如果条件运行，
一定是再加一个或多个jar包，jar包之间用nginx或nacos管理都行，用负载均衡来提升性能。
比如一个jar包能应对一秒500个并发，那么2个节点至少可以应对700个左右的并发。
事实上真实项目一般对并发量有预估，实际上线后应该差不多，所以多加jar包应该能满足大多数的情况。
2 反过来说单体版的措施，其实提升性能的程度很优先。比如增加tomcat的线程数，
或者引入MySQL数据库的连接池或连接池的数量，估计大多数情况下，性能增幅能超过20%就不错了。
比如一秒500个并发量，单机版方面提升性能，估计用了1周，尝试各种方法，而且估计大多数方法还未必可用，
能提升到600一秒真就不错了。3 提升并发量的另外一个方面是数据库，这块可以引入Redis或MyCAT分库组件，
来提升数据库的吞吐量，从而提升整体系统架构的吞吐量。
4 另外有一点，在真实项目里，应对过高并发的人应该都有经验，上线前，会通过压力测试来确保性能需求。
比如某系统上线后要应对500并发量，上线前一般是用jmeter同时发500个请求，看这些请求的处理时间，如果发现不行，
应该是多上节点，即引入集群，或者是看问题出在哪里，比如要引入redis缓存。当下不少公司，哪怕自身没有高并发需求，
也会问这方面的问题，下面给出回答这类问题的基本套路，按这样说了，对方至少会认为你有过相关经验。
1 如果以前有高并发的真实项目经验，就直接说，我在xx项目里做过高并发调优，并发量是多少。如果以前没有做过，
可以说，在之前的项目里，客户对后端接口有性能要求，比如要1秒内返回，对此我有过经验。这里请记住，如果你之前没有高并发真实项目经验，
但在学习项目里了解过，那还是建议通过提升接口性能来说，因为这毕竟属于真实经验，而且这块经验和高并发经验价值差不多。
2 然后说，为了达到高并发需求，或者接口要在1秒内返回，在上线前我有压测经验，具体是用jmeter做。说这块的目的，
是让面试官确信你确实有过高并发或性能方面的经验，然后在此基础上，还能通过压测说你解决过的实际问题。
3 在说高并发或性能方面的经验时，可以说单机版，但更多可以说组件经验。比如为了应对高并发，
我们引入了Spring Cloud Alibaba里的Nacos，让多个jar包注册到nacos注册中心上，从而提升性能。
或者是通过压测发现数据库性能是瓶颈，由此引入了redis，在此基础上还可以说，通过压测发现和解决过数据库性能问题，
比如用执行计划和索引，甚至可以说单机版SQL调优的经验，此类说辞网上一大堆。但这里别说手写多线程，因为当下高并发或性能提升，
基本上是使用组件，甚至可以这样说，如果你在面试中说，你在项目里是手写了一套多线程调度来应对高并发，
或者是手写锁来管理高并发下的数据竞争，面试机会会挂。4 事实上，对3到5年经验的Java求职者来说，
说高并发别空对空，就说用分布式组件。在此基础上再说些细节和解决过的问题。
比如你说，你们系统后端接口本来是2秒返回，这个数据是通过压测得到的，后来加了nacos，
引入 了2个jar包，接口就在1秒内返回了。或者再说，在这过程中，你解决了若干SQL慢查询，
用索引或单机版SQL优化技术都行，这样对方面试官真就相信你做过。这点很重要，你空对空说，
人家只认你的理论技能，你说你用过，哪怕是简单用组件，对方会认为你有这方面的经验。



别在循环里写select insert delete 已经优化了80%的性能问题
多个io操作合并成并行同时执行，又优化了10%
剩下的10%性能问题，90%的程序员终其一生都无法触及，能触及的程序员都知道怎么回答这个问
举个例子 你有1m文本的数据流，你需要在2000qps的流量下计算其索引并写入es*。假设这个内容是
xml，你会发现你的瓶颈在于提取索引，和写入e。
这时候你怎么优化spring boot，quarkus*，gin*，ktor*，expressis*..都没啥用，因为web性能远
超你的算力。
与其说优化springboot* 不如考虑考虑如何批量写入es和加快提取速度，这时候都没到优化mq*的时
候。
io，才是瓶颈。那个例子是我们真实遇到的问题，甚至当时还需要考虑如何加快mq消息消费，解决方案
就是快速消费，本地磁盘缓冲，在流量大的时候自动转换为批处理，流量小的时候做流处理，这里用到
了自定义的线程池，最后是es批量写入。
这些跟springboot无关，这些逻辑最终可以在任意java框架下运行，emmmm不过这些辑似乎一些现
代话流处理框架自带，不过当时轮子还是自己造了。
深刻记得，当时从没有思路到有思路，就是看了《Java并发编程的艺术》然后听到一句话“微观世界的
规则可以应用到宏观世界"（量子力学除外）
虽然最后实现跟那本书没啥关系，不过⋯那本书确实好啊