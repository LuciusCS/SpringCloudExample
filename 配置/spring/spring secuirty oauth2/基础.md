



### 各个类之间的关系

SecurityContextHolder它持有的是安全上下文（SecurityContext）的信息,当前操作的用户是谁，该用户是否已经被认证，他拥有哪些角色权等等，这些都被保存在SecurityContextHolder中。

SecurityContext安全上下文，主要持有Authentication对象，如果用户未鉴权，那Authentication对象将会是空的

Authentication  鉴权对象，该对象主要包含了用户的详细信息（UserDetails）和用户鉴权时所需要的信息，如用户提交的用户名密码、Remember-me Token，或者digest hash值等，按不同鉴权方式使用不同的Authentication实现


UserDetails# 这个接口规范了用户详细信息所拥有的字段，譬如用户名、密码、账号是否过期、是否锁定等


```
 SecurityContextHolder
    .getContext()         //返回:SecurityContext
    .getAuthentication() // 返回：Authentication
    .getPrincipal()) // 这里就是 Authentication 内部保存的 UserDetail 对象
    .getUsername();

```


Authentication 的 getCredentials() 与 UserDetails 中的 getPassword() 需要被区分对待，前者是用户提交的密码凭证，后者是用户正确的密码，认证器其实就是对这两者的比对。

Authentication 中的 getAuthorities() 实际是由 UserDetails 的 getAuthorities() 传递而形成的。

Authentication 接口中的 getUserDetails() 方法吗？其中的 UserDetails 用户详细信息便是经过了 AuthenticationProvider 之后被填充的。


UserDetailsService 和 AuthenticationProvider 两者的职责常常被人们搞混，UserDetailsService 它纯粹是一个用于用户数据的 DAO，除了向框架内的其他组件提供该数据之外，没有其他功能。特别是，它不对用户进行身份验证，这是由 AuthenticationManager 完成的。所以在多数情况下，如果需要自定义身份验证过程，直接实现 AuthenticationProvider 更有意义。

UserDetailsService 常见的实现类有

JdbcDaoImpl 从数据库加载用户
InMemoryUserDetailsManager 从内存中加载用户
也可以自己实现 UserDetailsService，通常这更加灵活。



### Authentication

Authentication 可以看作一条用户认证信息 , 其中包括各种凭证信息，以及用户的详细信息,
Authentication 接口：它是 Spring Security 中非常核心的概念，表示用户认证信息，通常由 AuthenticationManager 进行创建并存储在 SecurityContext 中。


```
public interface Authentication extends Principal, Serializable {
    Collection<? extends GrantedAuthority> getAuthorities();  ///返回与用户相关的权限（通常是角色或其他权限）。GrantedAuthority 接口只有一个string类型的变量

    Object getCredentials();  ///返回与认证凭证相关的信息，通常是密码或令牌。该方法的返回值是 Object 类型。

    Object getDetails();  ///返回认证的详细信息，例如客户端请求信息，或者其他任何用户的附加信息。该方法的返回值是 Object 类型。

    Object getPrincipal();  ///返回用户的主体信息，通常是表示用户的标识符（例如用户名）。这个方法通常是用来获取用户的身份，通常返回一个 UserDetails 或 OAuth2User 对象，或者只是一个字符串（例如用户名）。

    boolean isAuthenticated(); ///返回用户是否已经认证。如果返回 true，表示用户已认证；如果返回 false，表示用户未认证。

    void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;  ///设置用户的认证状态，通常在 Authentication 对象创建时由 AuthenticationManager 设置。
}

```


默认行为：在 Spring Security 中，getPrincipal() 方法的默认返回值是表示用户身份的对象，通常为 UserDetails 或 OAuth2User。
如果你使用的是基于 UsernamePasswordAuthenticationToken 的认证方式，getPrincipal() 默认返回的是一个 UserDetails 对象。
如果你使用的是基于 OAuth2 的认证，getPrincipal() 返回的可能是一个 OAuth2User 对象。
自定义 getPrincipal() 返回值：
自定义认证对象：你可以根据需求自定义 Authentication 的实现类，并在 getPrincipal() 方法中返回一个你自定义的用户对象。例如，你可以返回一个自定义的 UserDetails 类，或者一个完全自定义的对象，来表示用户信息。
示例：如果你希望将 getPrincipal() 返回一个 UserDetails 对象，你可以这样做：


### AuthenticationProvider

在AuthenticationProvider中提供自定义的认证方式

```
public interface AuthenticationProvider {
    Authentication authenticate(Authentication authentication) throws AuthenticationException;

    boolean supports(Class<?> authentication);
}


```


```
Authentication authentication = new UsernamePasswordAuthenticationToken(username, password);
authentication = authenticationManager.authenticate(authentication);
///将认证信息存入 SecurityContextHolder：
SecurityContextHolder.getContext().setAuthentication(authentication);
```

```
authentication = authenticationManager.authenticate(authentication);
这一行代码通过 authenticationManager（认证管理器）来验证用户的凭证。Spring Security 会根据你配置的认证机制（例如：内存认证、数据库认证、自定义认证提供者等）来验证用户的凭证。

这个过程会触发以下流程：

**重要**
AuthenticationManager 会委托给 AuthenticationProvider（通常是 DaoAuthenticationProvider 或者你自定义的 AuthenticationProvider）。
AuthenticationProvider 会尝试使用用户提供的凭证（用户名、密码）来查找用户的详细信息，验证密码是否正确。
如果验证成功，AuthenticationManager 会返回一个新的 Authentication 对象，该对象包含了认证后的用户信息，并且 isAuthenticated() 会返回 true。
如果认证失败，authenticate 方法会抛出 AuthenticationException，并且认证流程中断。



///将认证信息存入 SecurityContextHolder：
SecurityContextHolder.getContext().setAuthentication(authentication);
一旦认证成功，SecurityContextHolder 会保存认证信息（即 Authentication 对象），这使得在应用程序的其他部分（如过滤器、控制器等）可以访问到当前用户的认证状态和权限信息。
SecurityContextHolder 的作用是跨请求共享用户的认证状态，以便在请求的生命周期内，应用程序可以随时访问当前用户的信息。





在新的 Spring Authorization Server 中，你需要通过自定义配置类来配置授权服务器，而不再使用 AuthorizationServerConfigurerAdapter。
新版本的授权服务器配置采用了更简洁的 OAuth2AuthorizationServerConfigurer 类和相关配置。新版中 AuthorizationServerEndpointsConfigurer也米有了



WebSecurityConfigurerAdapter 已经在 Spring Security 5.0 之后逐渐被弃用

代替方式：SecurityFilterChain 和 SecurityConfigurer
SecurityFilterChain 和 SecurityConfigurer 现在成为了 Spring Security 的主力配置方式。


SecurityFilterChain 配置方式

在新版 Spring Security 中，配置安全的方式是定义一个 SecurityFilterChain bean，来代替原来的 WebSecurityConfigurerAdapter。

SecurityFilterChain: 这个 bean 用来定义 Spring Security 的配置。它接受一个 HttpSecurity 对象，通过这个对象来配置应用的安全策略，比如 URL 权限、登录方式、注销配置等。
http.build(): 使用 http.build() 来返回配置好的 SecurityFilterChain 实例，Spring Security 将会使用它来处理请求。
@EnableWebSecurity: 这个注解仍然需要使用，它启用了 Spring Security 的基本配置和过滤器链。

```
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    // 配置 SecurityFilterChain
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll()  // 公开的 URL
                .anyRequest().authenticated()  // 其他 URL 需要认证
            .and()
            .formLogin()  // 启用表单登录
                .loginPage("/login")  // 自定义登录页面
            .and()
            .logout()  // 启用注销
                .logoutUrl("/logout");  // 自定义注销 URL
        return http.build();  // 返回配置的 SecurityFilterChain
    }

    // 配置内存中的用户认证信息
    @Bean
    public UserDetailsService userDetailsService() {
        return new InMemoryUserDetailsManager(
            User.withUsername("user")
                .password("{noop}password")  // 使用 {noop} 来表示不加密的密码
                .roles("USER")
                .build()
        );
    }
}

```


如果你需要配置更复杂的认证和授权，可以继续使用 SecurityConfigurer 来扩展配置。例如，配置基于数据库的认证：

```
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.jdbc.JdbcUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    // 配置 SecurityFilterChain
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            .and()
            .formLogin()
            .and()
            .logout();
        return http.build();
    }

    // 配置基于 JDBC 的用户认证
    @Bean
    public UserDetailsService userDetailsService() {
        JdbcUserDetailsManager userDetailsService = new JdbcUserDetailsManager();
        // 配置数据源、查询用户的 SQL 等...
        return userDetailsService;
    }
}

```


假设你有多个 AuthenticationProvider，你可以这样配置 AuthenticationManager：

/***
Spring Security 6.0采用了基于Lambda表达式的DSL配置方式，取代了之前的纯链式调用方式，使得配置更加灵活和直观。
一些方法名称也进行了修改，例如antMatchers替换为requestMatchers。
***/

@Configuration
public class SecurityConfig {

    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http) throws Exception {
        return http.getSharedObject(AuthenticationManagerBuilder.class)
                   .authenticationProvider(daoAuthenticationProvider()) // 注册 DaoAuthenticationProvider
                   .authenticationProvider(jwtAuthenticationProvider()) // 注册 JwtAuthenticationProvider
                   .build();
    }

    @Bean
    public AuthenticationProvider daoAuthenticationProvider() {
        return new DaoAuthenticationProvider();
    }

    @Bean
    public AuthenticationProvider jwtAuthenticationProvider() {
        return new JwtAuthenticationProvider();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll() // 公开路径
                .anyRequest().authenticated() // 其他需要认证
            .and()
            .formLogin()
            .and()
            .httpBasic();

        return http.build();
    }
}
AuthenticationManager 调用authenticate的流程


AuthenticationManager 通过遍历所有注册的 AuthenticationProvider 来决定使用哪个 AuthenticationProvider。
AuthenticationProvider 通过 supports() 方法来判断自己是否能够处理当前的 Authentication 类型。
基于不同的认证方式（如用户名/密码认证、JWT认证等），不同的 AuthenticationProvider 负责处理不同类型的认证请求。
这种方式使得 Spring Security 能够同时支持多种认证方式，并根据不同的认证请求自动选择适当的 AuthenticationProvider。

如何决定使用哪个 AuthenticationProvider
当客户端发送认证请求时，Spring Security 会根据 Authentication 对象的类型来决定使用哪个 AuthenticationProvider。具体地：

如果请求中包含用户名和密码，Spring 会创建一个 UsernamePasswordAuthenticationToken，并将其传递给 AuthenticationManager。
如果请求中包含 JWT 令牌，Spring 会创建一个 JwtAuthenticationToken，并将其传递给 AuthenticationManager。
AuthenticationManager 会根据 Authentication 对象的类型（即 AuthenticationToken 的子类）来查找适当的 AuthenticationProvider 进行认证。


```
public class CustomUserDetailsService implements UserDetailsService {
    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username);

        ///authorities 中同时有 roles 及 permission 
        List<GrantedAuthority> authorities = new ArrayList<>();
        for (Role role : user.getRoles()) {
            authorities.add(new SimpleGrantedAuthority("ROLE_" + role.getName()));
        }
        for (Permission permission : user.getPermissions()) {
            authorities.add(new SimpleGrantedAuthority(permission.getName()));
        }

        return new CustomUserDetails(user.getUsername(), user.getPassword(), authorities);
    }
}


http.authorizeHttpRequests((requests) -> 
    requests
        .requestMatchers("/admin").hasAuthority("ROLE_ADMIN")  // 需要 ROLE_ADMIN 权限
        .requestMatchers("/hello").hasRole("USER")  // 需要 ROLE_USER 角色
        .anyRequest().authenticated()  // 其他请求需要认证
);

```




## AuthorizationManager 和 AuthenticationManager 是 Spring Security 中两个不同的概念，它们分别用于 权限管理 和 身份认证。

1、 AuthenticationManager：身份认证（Authentication）

  AuthenticationManager 主要用于 用户认证，即 验证用户的身份是否合法。
  作用：处理身份验证，检查用户的 用户名 / 密码 / Token 是否正确。返回一个 已认证的 Authentication 对象（如果认证成功）。认证失败时，抛出 认证异常（AuthenticationException）。

2、 AuthorizationManager：权限管理（Authorization）

AuthorizationManager 主要用于 访问控制，即 用户是否有权限访问某个资源。
检查用户是否有访问权限。根据 角色（Role） 或 权限（Authority） 决定是否允许访问。用于 方法级权限控制（@PreAuthorize）或 URL 访问控制。


特性	    AuthenticationManager	                                AuthorizationManager
作用	            认证（验证身份）                                        授权（权限管理）
触发时机	            用户登录	                                    访问受保护资源时
返回值	        Authentication 对象	                            AuthorizationDecision 结果
失败时	    抛出 AuthenticationException	                            访问被拒绝（403）
应用场景	登录时校验用户名 / 密码 / Token	                        控制 API / 方法 / 资源的访问权限
典型配置	AuthenticationProvider + UserDetailsService	     AuthorizationManager + @PreAuthorize



重要的类和接口



AuthenticationFilter 拦截请求并将身份验证职能委托给AuthenticationManager

为了检查用户名和密码 AuthenticationProvider会使用UserDetailService和PasswordEncoder

UserDetails

Authentication

AuthenticationManagerBuilder   用于创建 AuthenticationManager

AuthenticationManager   的实现类 ProviderManager 管理多个 AuthenticationProvider，通过 AuthenticationManagerBuilder 将多个 AuthenticationProvider 注册到 ProviderManager 中

AuthenticationProvider  接口里面有 supports，表示支持那种认证方式

SecurityFilterChain 

SecurityConfigurer

UserDetailsService  用于从数据库或其他途径读取用户信息，并赋值给 UserDetails




Spring Security OAuth2 中重要的类和接口

ClientRegistrationRepository
OAuth2AuthorizationServerConfigurer
