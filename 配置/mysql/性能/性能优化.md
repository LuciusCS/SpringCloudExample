


MySQL InnoDB Cluster 给你解决了 高可用，但性能（特别是高并发、大数据量场景）更多要靠 架构设计 + 优化手段 来提升。



## MySql 性能优化

### 1. 应用层（最先优化，见效最快）
   - 避免 SELECT *，只取需要字段。
   - 使用 分页优化：大数据量分页时用 id > ? LIMIT ?，避免 LIMIT offset,N 大偏移扫描。
   - 批量写入替代循环单条写入。
   - 避免频繁事务提交，能合并的事务尽量合并。
   - 使用连接池（Druid/HikariCP），合理设置：
        * initialSize = 5~10
        * maxActive = 2~4 × CPU 核数
        * maxWait < 3s
     
### 2. SQL 与索引优化
   - 用 EXPLAIN 检查慢查询执行计划，确认是否走索引。
   - 建立合适的索引：
        * 高频 WHERE 条件 → 普通索引。
        * 覆盖索引（包含查询字段）减少回表。
        * 组合索引时最左匹配原则。
   - 避免索引失效：
        * where date(create_time) > '2025-01-01' ❌
        * 改为 where create_time > '2025-01-01' ✅
   - 使用 slow_query_log 找出慢 SQL，集中优化。

### 3. 数据库配置优化
   - innodb_buffer_pool_size：设置为物理内存的 50%~70%。
   - innodb_log_file_size：加大（如 512MB~1GB），减少 checkpoint。
   - innodb_flush_log_at_trx_commit = 1（最安全）→ 可调为 2（性能更高）。
   - max_connections：根据应用并发量合理设置，避免过大。
   - thread_cache_size：减少线程创建销毁开销。

### 4. 架构优化
   - 读写分离：
       * 写 → Primary
       * 读 → Secondary
       * MySQL Router 或 ShardingSphere。
   - 缓存：
       * Redis 缓存热点数据，减少数据库压力。
       * 可加本地缓存（Guava/Caffeine）。
   - 分库分表：
       * 单表超过 5000万行时考虑。
       * 按用户 ID / 时间拆分。
   - 异步化：
       * 将非核心写操作（日志、审计）异步入库，削峰填谷。
### 5. 硬件与系统层
   - SSD/NVMe 替代 HDD。
   - 增加内存，保证更多热数据能进 buffer pool。
   - 调整 OS 参数（如 vm.swappiness=1，减少 swap）。
   - 在云上时考虑 高性能云数据库（Aurora、PolarDB、TiDB）。
## 6. 监控与持续优化
   - 打开 performance_schema，分析 SQL 执行情况。
   - 使用 pt-query-digest（Percona Toolkit）分析慢日志。
   - 监控 QPS/TPS、连接数、Buffer Pool 命中率。
   - 定期归档/清理历史数据，避免表无限膨胀。


📌 落地顺序建议：
先 SQL 和索引（通常能解决 80% 性能问题）。
再做 参数调优（buffer pool/log size）。
读写分离 + 缓存（提升扩展性）。
分库分表/分布式数据库（最后手段）。