



### 并发数 vs CPU 核心数

🟢 1. CPU 核心数的确是物理上限
一个 CPU 核心在同一时刻只能执行一个线程（忽略超线程）。
所以如果你有 4 核 CPU，理论上 真正同时运行的线程最多就是 4 个。
这就是「并行 (parallelism)」的极限。

🟢 2. 但“并发数”不等于“同时并行的线程数”
并发 (concurrency) 指的是：系统在同一时间段内“正在处理的请求数量”。
并行 (parallelism) 指的是：真正同时执行的线程数，受 CPU 核心数限制。
👉 举个例子：
4 核 CPU，开了 200 个 Tomcat 工作线程。
100 个请求同时进来：
真正被 CPU 核心执行的可能只有 4 个；
另外 96 个在等待磁盘 IO、数据库、网络返回（它们也算“并发请求”）。
所以，并发数通常 远大于 CPU 核数，因为大部分请求会阻塞在 IO，而不是占用 CPU。

🟢 3. 阻塞 vs 非阻塞的差别
阻塞模型 (Tomcat, Servlet)
每个请求占用一个线程。
并发数 ≈ 线程池大小。
CPU 核数决定能高效执行多少线程，但线程可以超配（比如 8 核配 200 个线程，因为大多数线程在等 IO）。
非阻塞模型 (Netty, WebFlux)
少量线程就能处理大量请求（通过事件驱动）。
并发数主要受内存、连接池、队列大小限制，而不是 CPU 核数。

🟢 4. 关系总结
CPU 核数 → 决定了“真正同时执行的计算任务”上限（并行度）。
线程池/事件循环 → 决定了能同时挂起/处理多少请求（并发度）。
并发数 ≠ CPU 核数，并发数通常可以远大于 CPU 核数。