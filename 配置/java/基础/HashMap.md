


## HashMap 的 key 可以是任何对象或数据类型，但必须满足以下条件：
必须实现 hashCode() 方法。
必须实现 equals() 方法（尤其是对于自定义类）。
最好选择不可变对象作为 key，避免在使用过程中修改对象的关键字段。


## HashMap 初始容量 计算方法


面试回答要素

回答什么情况下会第一扩容，举例说明，新数组大小，阈值大小
以后什么情况下会再次扩容，这次是怎么计算新数组大小，及阈值大小的

## HashMap、ConcurrentHashMap初始化阈值为什么要是8，才转为红黑树？


## 手写HashMap

要点：

底层是数组结构
hash冲突的时候，转换为链表
考虑扩容处理


## HashMap在并发下会产生什么问题？有什么替代方案?(HashTable, ConcurrentHashMap)。它们两者的实现原理。

### HashMap在并发下会死循环

```java
// JDK7的扩容代码确实会导致死循环
// 但JDK8只是修复了死循环，并发问题依然存在！

// 在JDK8+中，并发put会导致：
// 1. 数据覆盖（值丢失）
// 2. size计算不准
// 3. 红黑树结构破坏

Map<String, String> map = new HashMap<>();
// 两个线程同时put，可能只有一个线程的值被保留

```

## HashMap 为什么不用平衡树，而用红黑树

