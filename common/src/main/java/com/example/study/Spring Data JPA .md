



## 事务提交过程 Spring Data JPA 事务提交流程
1.  数据操作
当你调用 save()、update() 或 delete() 等方法时，Spring Data JPA 会将实体的变动保存在 EntityManager 中。EntityManager 是 JPA 中用于管理实体的接口。

2.  一级缓存 (EntityManager 缓存)
在 事务内，Spring Data JPA 会将操作的实体对象放入 一级缓存，也就是 EntityManager 的内存中。一级缓存是 事务级别的缓存，只对当前事务有效，数据变动只会保存在内存中，尚未写入数据库。

3. 执行 flush()
当事务提交时，EntityManager 会 flush，即将内存中的变动（一级缓存）写入数据库（执行 SQL 操作如 INSERT、UPDATE、DELETE）。 

4. 数据库的缓存和操作  InnoDB 缓存
当 JPA 执行 flush() 时，数据会被持久化到数据库中，但是具体的持久化过程和数据库的行为还受到 InnoDB 存储引擎的影响。以下是几个关键点：
    内存缓冲池（Buffer Pool）：
         InnoDB 会将数据写入其 内存缓冲池，这是一块内存区域，用来存储数据库的数据页（data pages）。这意味着，即使执行了 flush()，数据首先会写入内存缓存，而不直接写入磁盘，直到达到一定条件才会真正持久化到磁盘。
         数据写入内存缓冲池时，InnoDB 会按照 redo log 记录所有的修改操作，这些修改操作保证了事务的可恢复性。
    Redo Log：
    Redo Log 会记录所有修改过的数据，并且用于事务的持久化保障。无论数据是否被写入磁盘，flush() 都会将数据操作记录到 redo log 中。事务提交时，InnoDB 会将这些日志写入磁盘。
          flush() 时，InnoDB 会将变动刷写到 redo log，但并不等同于提交事务。事务提交（commit()）时，InnoDB 会确保 redo log 写入磁盘，从而保证数据一致性。
    Write-Ahead Log（WAL）：
         InnoDB 在执行 flush() 时，会先将数据写入 WAL，即日志文件，以保证数据修改不会丢失。这种方式是为了支持 ACID 特性中的 Durability（持久性）。

5. 事务日志（Transaction Logs）
    在执行 flush() 后，MySQL 会将事务相关的变更记录到事务日志（binlog 和 redo log）。这些日志确保了数据的 持久性，并且能在系统崩溃时帮助恢复数据。

6. 延迟写入
MySQL 在执行 flush() 时，不会立即将所有数据写入磁盘，而是会根据以下几个条件进行延迟写入：
内存缓冲区已满，InnoDB 会将数据从缓冲池写入磁盘。
checkpoint（检查点）时，InnoDB 会周期性地将数据从内存写入磁盘，保证数据库状态一致。

7. 锁机制
在执行 flush() 时，可能会对数据表和数据行施加 锁。这些锁保证了在数据写入过程中的一致性和并发安全。
行级锁：InnoDB 采用行级锁来保证数据修改时的并发性，避免多个事务同时修改同一行。
表级锁：对于某些操作（如 ALTER 表）可能会涉及表级锁。

8. 外键约束
如果表之间有 外键约束，flush() 操作时会检查数据的一致性。比如，如果你在 Album 表中修改了某个 外键字段（例如，指向 Singer 表的外键），数据库会检查这个外键约束是否有效，确保数据一致性。

9. 触发器（Triggers）
在执行 flush() 时，如果数据库中定义了触发器（如 BEFORE INSERT、AFTER UPDATE 等），这些触发器会被执行，从而对数据进行额外的处理，如自动更新某些字段、记录日志等。 

10. 事务提交 (commit)
flush() 并不会提交事务，只是将内存中的变动持久化到数据库。当事务提交（commit()）时，事务将被完成，数据库中的数据才算真正“写入”。
Spring Data JPA 会执行事务管理器的 commit() 操作，这时 数据库才会真正接收到数据变动，并且事务会结束。

11. 事务提交（commit）
当事务 commit() 时，以下操作发生：
持久化事务日志：提交之前的事务日志（redo log）会被持久化到磁盘。
释放锁：在事务提交后，数据库会释放所持有的锁，允许其他事务访问或修改数据。
实际写入磁盘：MySQL 会将 内存缓冲池 中的数据写入磁盘，确保数据的持久性。

12. 二级缓存（如果启用）
如果你配置了 二级缓存（例如 Hibernate + Ehcache/Redis），事务提交后，相关数据会被存储在缓存中。缓存机制会提高后续读取的效率，避免频繁访问数据库。


### Mysql 自动事务提交

1. MySQL 默认启用 自动提交事务，这意味着每一条独立的 SQL 语句都会在执行完成后自动提交为一个单独的事务。 
    每次执行 SQL 语句时，数据库会为该语句创建一个事务，并在语句执行完毕后立即提交。
2. Spring Data JPA 是基于 Spring 事务管理的一部分，Spring 提供了更强大的事务控制能力，支持跨多个 SQL 语句的事务管理，
     并且能够保证事务的 原子性、一致性、隔离性 和 持久性（即 ACID 特性）。Spring 的事务管理不仅局限于单条 SQL 语句，还能确保多个操作在一个事务范围内提交。

注：  1. 单条 SQL 时，Spring 的事务管理并不会完全控制提交行为，但它仍然会起到一个管理作用，尤其是在你需要处理错误回滚等场景时。
     2. 多条 SQL 操作时，Spring 的事务管理更为重要，因为它可以确保所有操作在同一个事务内执行，事务的提交和回滚都由 Spring 管理
     3. 当 MySQL 事务提交失败时，Spring 会捕获这个失败，并通过 JpaTransactionManager 对事务进行处理。
